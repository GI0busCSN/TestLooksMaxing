import{Z as m,$ as P,a0 as A,i as b,a1 as G,a2 as y,a3 as B,Y as O}from"./index-nBUwtn7G.js";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const V=()=>{};function j(...e){if(e.length!==1)return A(...e);const t=e[0];return typeof t=="function"?m(G(()=>({get:t,set:V}))):b(t)}function x(e,t){function n(...r){return new Promise((a,i)=>{Promise.resolve(e(()=>t.apply(this,r),{fn:t,thisArg:this,args:r})).then(a).catch(i)})}return n}const F=e=>e();function z(e=F,t={}){const{initialState:n="active"}=t,r=j(n==="active");function a(){r.value=!1}function i(){r.value=!0}const c=(...u)=>{r.value&&e(...u)};return{isActive:m(r),pause:a,resume:i,eventFilter:c}}function I(e,t,n={}){const{eventFilter:r=F,...a}=n;return P(e,x(r,t),a)}function $(e,t,n={}){const{eventFilter:r,initialState:a="active",...i}=n,{eventFilter:c,pause:u,resume:l,isActive:p}=z(r,{initialState:a});return{stop:I(e,t,{...i,eventFilter:c}),pause:u,resume:l,isActive:p}}function f(e){return new Promise((t,n)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>n(e.error)})}function E(e,t){let n;const r=()=>{if(n)return n;const a=indexedDB.open(e);return a.onupgradeneeded=()=>a.result.createObjectStore(t),n=f(a),n.then(i=>{i.onclose=()=>n=void 0},()=>{}),n};return(a,i)=>r().then(c=>i(c.transaction(t,a).objectStore(t)))}let h;function d(){return h||(h=E("keyval-store","keyval")),h}function K(e,t=d()){return t("readonly",n=>f(n.get(e)))}function T(e,t,n=d()){return n("readwrite",r=>(r.put(t,e),f(r.transaction)))}function Y(e,t,n=d()){return n("readwrite",r=>new Promise((a,i)=>{r.get(e).onsuccess=function(){try{r.put(t(this.result),e),a(f(r.transaction))}catch(c){i(c)}}}))}function Z(e,t=d()){return t("readwrite",n=>(n.delete(e),f(n.transaction)))}function C(e,t,n={}){const{flush:r="pre",deep:a=!0,shallow:i=!1,onError:c=o=>{console.error(o)},writeDefaults:u=!0,serializer:l={read:o=>o,write:o=>o}}=n,p=y(!1),s=(i?y:b)(t),w=B(t);async function S(){try{const o=await K(e);o===void 0?w!=null&&u&&await T(e,l.write(w)):s.value=l.read(o)}catch(o){c(o)}p.value=!0}S();async function v(){try{if(s.value==null)await Z(e);else{const o=O(s.value),D=l.write(o);await Y(e,()=>D)}}catch(o){c(o)}}const{pause:g,resume:R}=$(s,()=>v(),{flush:r,deep:a});async function W(o){g(),s.value=o,await v(),R()}return{set:W,isFinished:p,data:s}}export{C as u};
